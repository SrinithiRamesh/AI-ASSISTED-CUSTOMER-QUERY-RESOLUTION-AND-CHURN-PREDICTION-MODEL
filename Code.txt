!pip install flask-ngrok 
!pip install flask flask-ngrok sentence-transformers scikit-learn pandas 
!pip install ngrok 
!pip install pyngrok 
from pyngrok import ngrok 
!pip install sentence-transformers 
pip install numpy pandas scikit-learn 
pip install Flask Flask-Ngrok pandas scikit-learn xgboost sentence-transformers tabulate 
import numpy as np 
import pandas as pd 
import xgboost as xgb 
from sklearn.model_selection import train_test_split, RandomizedSearchCV 
from sklearn.metrics import accuracy_score, roc_auc_score 
from sklearn.preprocessing import StandardScaler, LabelEncoder 
from sklearn.decomposition import PCA 
from sklearn.feature_selection import SelectKBest, chi2 
from flask import Flask, request, jsonify, render_template_string 
from sentence_transformers import SentenceTransformer, util 
import random 
from tabulate import tabulate 
from flask_ngrok import run_with_ngrok 
# Load the churn data 
data = pd.read_csv('WA_Fn-UseC_-Telco-Customer-Churn.csv') 
# Drop customerID (as it's not useful for prediction) 
data.drop('customerID', axis=1, inplace=True) 55 

# Handle missing values 
data['TotalCharges'] = pd.to_numeric(data['TotalCharges'], errors='coerce') 
data['TotalCharges'].fillna(data['TotalCharges'].median(), inplace=True) 
# Encode categorical variables 
for col in data.select_dtypes(include=['object']).columns: 
if col != 'Churn': 
data[col] = LabelEncoder().fit_transform(data[col]) 
# Convert Churn column to binary 
data['Churn'] = data['Churn'].map({'No': 0, 'Yes': 1}) 
# Split the dataset into features (X) and target (y) 
X = data.drop('Churn', axis=1) 
y = data['Churn'] 
# Feature selection using SelectKBest 
k_best = SelectKBest(chi2, k=10) # Select top 10 features 
X_new = k_best.fit_transform(X, y) 
# Scale the selected features 
scaler = StandardScaler() 
X_scaled = scaler.fit_transform(X_new) 
# Dimensionality reduction using PCA (optional) 
pca = PCA(n_components=8) # Reduce to 8 principal components 
X_pca = pca.fit_transform(X_scaled) 
# Split the data into training and testing sets 
X_train, X_test, y_train, y_test = train_test_split( 
X_pca, y, test_size=0.2, random_state=42, stratify=y 
) 
# Define the XGBoost model 
xgb_model = xgb.XGBClassifier( 
use_label_encoder=False, 
eval_metric='logloss', 
objective='binary:logistic', 56 

random_state=42 
) 
# Set up the hyperparameter grid for tuning 
param_grid = { 
'n_estimators': [100, 200, 300], 
'learning_rate': [0.01, 0.05, 0.1], 
'max_depth': [3, 5, 7], 
'min_child_weight': [1, 3, 5], 
'subsample': [0.8, 1.0], 
'colsample_bytree': [0.8, 1.0], 
'gamma': [0, 0.1, 0.2], # Regularization parameter 
'reg_alpha': [0, 1e-2, 1e-1], # L1 regularization 
'reg_lambda': [1, 1.5, 2] # L2 regularization 
} 
# Use RandomizedSearchCV for hyperparameter tuning 
random_search = RandomizedSearchCV( 
estimator=xgb_model, 
param_distributions=param_grid, 
n_iter=50, # Number of parameter settings sampled 
scoring='accuracy', 
cv=3, # 3-fold cross-validation 
verbose=2, 
random_state=42, 
n_jobs=-1 # Use all available CPU cores 
) 
# Fit the randomized search to the training data 
random_search.fit(X_train, y_train) 
# Get the best model 
best_model = random_search.best_estimator_ 
# Predict on the test data 57 

y_pred = best_model.predict(X_test) 
# Evaluate the model 
accuracy = accuracy_score(y_test, y_pred) 
roc_auc = roc_auc_score(y_test, best_model.predict_proba(X_test)[:, 1]) 
# Print evaluation metrics 
print(f"Optimized XGBoost Accuracy: {accuracy:.4f}") 
print(f"Optimized XGBoost ROC AUC: {roc_auc:.4f}") 
# Load the query dataset and initialize SentenceTransformer 
sentence_model = SentenceTransformer('all-MiniLM-L6-v2') 
query_dataset = pd.read_csv('/content/question_solution_dataset (3).csv') 
question_embeddings = sentence_model.encode(query_dataset['Question'].str.lower(), convert_to_tensor=True) 
# Flask app setup 
app = Flask(__name__) 
run_with_ngrok(app) # This will enable Ngrok for accessing the app 
unresolved_queries = [] # Initialize unresolved queries list 
@app.route('/') 
def home(): 
return render_template_string(html_template) 
# HTML template for the webpage 
html_template = """ 
<!DOCTYPE html> 
<html lang="en"> 
<head> 
<meta charset="UTF-8"> 
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<title>Customer Query Resolution System</title> 
<style> 
body { 
font-family: Arial, sans-serif; 58 

background-color: #f0f4f8; 
margin: 0; 
padding: 0; 
display: flex; 
justify-content: center; 
align-items: center; 
height: 100vh; 
color: #333; 
} 
.container { 
width: 90%; 
max-width: 600px; 
background: #fff; 
padding: 30px; 
border-radius: 10px; 
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); 
} 
h1 { 
text-align: center; 
color: #007BFF; 
} 
label { 
font-size: 1.1rem; 
margin-bottom: 5px; 
display: block; 
} 
textarea { 
width: 100%; 
height: 80px; 
padding: 10px; 59 

margin-top: 10px; 
font-size: 1rem; 
border-radius: 5px; 
border: 1px solid #ccc; 
resize: none; 
} 
button { 
background-color: #007BFF; 
color: white; 
padding: 10px 20px; 
font-size: 1rem; 
border: none; 
border-radius: 5px; 
cursor: pointer; 
transition: background-color 0.3s; 
margin-top: 10px; 
} 
button:hover { 
background-color: #0056b3; 
} 
.response { 
margin-top: 20px; 
padding: 15px; 
border: 1px solid #ccc; 
border-radius: 5px; 
background-color: #e9ecef; 
} 
.support-button { 
background-color: #28a745; 
margin-top: 10px; 60 

} 
.support-button:hover { 
background-color: #218838; 
} 
@media (max-width: 600px) { 
.container { 
padding: 20px; 
} 
h1 { 
font-size: 1.5rem; 
} 
button, .support-button { 
width: 100%; 
} 
} 
</style> 
</head> 
<body> 
<div class="container"> 
<h1>Customer Query Resolution System</h1> 
<form id="query-form"> 
<label for="query">Enter your query:</label> 
<textarea id="query" name="query" required></textarea> 
<button type="button" onclick="sendQuery()">Submit</button> 
</form> 
<div id="response" class="response"></div> 
</div> 
<script> 
async function sendQuery() { 
const query = document.getElementById("query").value; 61 

const responseDiv = document.getElementById("response"); 
const response = await fetch("/query", { 
method: "POST", 
headers: { "Content-Type": "application/json" }, 
body: JSON.stringify({ query: query, customer_id: "0001" }) 
}); 
const result = await response.json(); 
responseDiv.innerHTML = "<strong>Response:</strong> " + (result.success ? result.response : result.error); 
responseDiv.innerHTML += `<br><button class="support-button" onclick="contactSupport()">Contact Customer Support</button>`; 
} 
async function contactSupport() { 
const query = document.getElementById("query").value; 
await fetch("/contact_support", { 
method: "POST", 
headers: { "Content-Type": "application/json" }, 
body: JSON.stringify({ query: query, customer_id: "0001" }) 
}); 
alert("Your request has been sent to customer support."); 
} 
</script> 
</body> 
</html> 
""" 
@app.route('/query', methods=['POST']) 
def query(): 
data = request.get_json() 62 

user_query = data.get('query', '').strip().lower() 
customer_id = data.get('customer_id') 
query_embedding = sentence_model.encode(user_query, convert_to_tensor=True) 
cosine_scores = util.pytorch_cos_sim(query_embedding, question_embeddings)[0] 
best_match_index = cosine_scores.argmax().item() 
best_match_score = cosine_scores[best_match_index].item() 
# Provide solution if score is above threshold 
if best_match_score >= 0.7: 
response = query_dataset['Solution'].iloc[best_match_index] 
return jsonify({"success": True, "response": response}) 
return jsonify({"success": False, "error": "Sorry, I can't get that."}) 
# Route to handle support requests 
@app.route('/contact_support', methods=['POST']) 
def contact_support(): 
data = request.get_json() 
customer_id = data.get('customer_id', 'unknown') 
query = data.get('query', '').strip() 
# Generate random values for features 
random_values = { 
"Customer ID": customer_id, 
"Query": query, 
"Churn Prediction": random.choice(["Yes", "No"]), 
"Dependents": random.choice(["Yes", "No"]), 
"Tenure Category": random.choice(["0-12 months", "13-24 months", "25-36 months", "37+ months"]), 
"Phone Service": random.choice(["Yes", "No"]), 
"Paperless Billing": random.choice(["Yes", "No"]), 
"Monthly Charges": round(random.uniform(20, 120), 2) 
} 
unresolved_queries.append(random_values) # Append to unresolved queries list 63 

return jsonify({"success": True}) 
# Route to get unresolved queries 
@app.route('/unresolved_queries', methods=['GET']) 
def get_unresolved_queries(): 
return jsonify(unresolved_queries) 
port = 5000 
ngrok.set_auth_token("2nuuB9WNU3xymLt9sVcKhQsjyrG_61pvVyjXpUKHvPCDsxuAy") 
public_url= ngrok.connect(port) 
print(f" * ngrok tunnel \"{public_url}\" -> \"http://127.0.0.1:{port}\"") 
if __name__ == '__main__': 
app.run() 
import pandas as pd 
# Assume unresolved_queries is a list of dictionaries with randomly generated customer data 
# Example structure: 
# unresolved_queries = [ 
# {'Customer ID': '0001', 'Query': 'why my bill is higher than usual', 'Churn Prediction': 0, 
# 'gender': 1, 'SeniorCitizen': 0, 'Partner': 1, 'Dependents': 1, 'tenure_cat': 4, 
# 'PhoneService': 1, 'PaperlessBilling': 0, 'MonthlyCharges': 52.56}, 
# {'Customer ID': '0002', 'Query': 'my internet is slow', 'Churn Prediction': 1, 
# 'gender': 0, 'SeniorCitizen': 1, 'Partner': 0, 'Dependents': 0, 'tenure_cat': 3, 
# 'PhoneService': 1, 'PaperlessBilling': 1, 'MonthlyCharges': 70.32}, 
# # more entries... 
# ] 
def display_unresolved_queries(): 
"""Display unresolved queries in a tabular format sorted by churn likelihood and then by monthly charges.""" 
if unresolved_queries: 
# Convert unresolved_queries list to DataFrame 
df = pd.DataFrame(unresolved_queries) 
# Sort by 'Churn Prediction' and then by 'MonthlyCharges' (both in descending order) 64 

df_sorted = df.sort_values(by=['Churn Prediction','Monthly Charges'], ascending=[False,False]).reset_index(drop=True) 
return df_sorted 
else: 
# Return an empty DataFrame with placeholder columns if there are no unresolved queries 
return pd.DataFrame(columns=['Customer ID', 'Query', 'Churn Prediction', 'gender', 'SeniorCitizen', 
'Partner', 'Dependents', 'tenure_cat', 'PhoneService', 
'PaperlessBilling', 'MonthlyCharges']) 
# Display unresolved queries in tabular format 
display_unresolved_queries()
